/*ＧＡによるナップザック問題解決プログラム*/
/*ナップザック問題とは、重量と価値の異なるN個の品物があり、そのうちM個を重量Wまで耐えられる袋に詰めるとき、価値の合計を最大にする品物の組合せを探し出す問題である*/
/*以下の個体数、世代数、交叉率、突然変異率等の変数（パラメータ）を様々に変えてＧＡの性能がどう変わるかを実験してみる*/
#include <stdio.h>
#include <stdlib.h>
//乱数を用いるときは以下のヘッダファイルをインストールする必要がある
#include <time.h>
//袋が耐えられる重量の最大値を定義（ここでは１００と定義。他の数字でも良い）
#define OMOSA_MAX 100
//一つの品物の重量の最大値を定義（ここでは１５と定義。他の数字でも良い）
#define ITEM_OMOSA_MAX 15
//全ての品物の数を定義（ここでは２０個としたが、他の数字でも良い）
#define ITEM_MAX 20
//一度に詰める品物の数を定義（ここでは１０個としたが、他の数字でも良い。これが数字列（解、個体、遺伝子ともいう）の長さになる）
#define GENE_LEN 10
//一つの世代を構成する個体数を定義（ここでは１００個体としたが、別の数字でも良い）
#define KOTAISUU 100
//何世代繰り返したらＧＡの処理を終わるかの世代数を定義（ここでは１００世代とする。これを決めないと処理が終わらない）
#define SEDAI_MAX 100
//何世代ごとにエリート（その世代で最優秀の個体）の点数を書き出すかを定義（ここでは、１０世代とする）
#define SEDAI_REC 10
//交叉率を定義（ここでは、９５％とする）
#define CROS_RATE 0.95
//突然変異率を定義（ここでは、５％とする）
#define MUTA_RATE 0.05

//乱数発生関数のプロトタイプ宣言
int rando (int);

//ここからメイン関数
void main () {
	//変数宣言
	int i , j , m;   //計算用のカウンター変数
	int counter;     //世代を表す変数
	int omosa[ITEM_MAX];  //各品物の重さを表す配列
	int gene[KOTAISUU][GENE_LEN];    //個体群を表す配列
	int temp_gene[KOTAISUU][GENE_LEN];   //ルーレット選択で用いる個体群の退避用配列
	double total , rulet_value , rulet_cf;  //ルーレット選択用変数
	int rulet_num;               //ルーレットで選択された個体の番号
	int pos;                     //交叉における切断点を表す変数
	int temp;                    //交叉における入替用変数
	double d_ret;                //交叉及び突然変異で用いる変数
	double seiseki[KOTAISUU];    //各個体の成績を表す配列（微妙な差も扱えるように、小数点以下も扱えるダブル型変数とする）
	double best_seiseki;         //エリート（その世代の個体群の中で最も成績のよい個体）を探すための変数
	int elite_num;               //エリート個体がその個体群の中の何番目の遺伝子であるかを表す変数
	int elite[GENE_LEN];         //エリート個体を保存のため待避する配列
	FILE *fp;                    //ファイルポインタ
	time_t t;                    //乱数発生用の変数

	//ここから処理が始まる
	//まず乱数を用いる場合は、この一行を書かなければならない
	srand((unsigned) time(&t));

	//まずこのケースにおける各品物の重さを決める（乱数で決める）。この条件で最も合計価値の高い品物の組合せを探索する
	for (i = 0 ; i < ITEM_MAX ; i ++) {
		omosa[i] = rando (ITEM_OMOSA_MAX);
	}
	//第一世代の個体群（初期個体群）を出鱈目に生成する（乱数発生関数を用いる）。解を表す数字列はこの場合、品物番号の羅列である
	//個体数分行うための繰り返し処理
	for (i = 0 ; i < KOTAISUU ; i ++) {
		//詰める品物の数だけ、品物番号を割り当てる繰り返し処理
		for (j = 0 ; j < GENE_LEN ; j ++) {
			//２０個の品物の番号（０〜１９）のどれかが出鱈目に割り当てられる（ここでは重複して同じ品物を選ぶ事を許している）
			gene[i][j] = rando (ITEM_MAX);
		}
	}
	//進化の過程に入る。まず世代交代数を表す変数を０に設定する
	counter = 0;
	//無限に処理を繰り返す命令。ただし、世代数が経過したらブレーク文で抜け出せる
	while (1) {
		//その世代の個体群の全ての個体の成績（選んだ品物の価値の合計）を算出する
		for (i = 0 ; i < KOTAISUU ; i ++) {
			//まずその個体の成績に０（double型なので０．０）点を代入する
			seiseki[i] = 0.0;
			//その個体が選んでいる品物の重さを足しこんでいく
			for (j = 0 ; j < GENE_LEN ; j ++) {
				seiseki[i] += omosa[gene[i][j]];
			}
			//ただし、袋が耐えられる重さを超えている組合せは最低点（０点）にする
			if (seiseki[i] > OMOSA_MAX) {
				seiseki[i] = 0.0;
			}
		}
		//全ての個体の評価値が得られたら、エリートを探し待避する。まず仮に個体群の中の一番最初の個体がエリートであると仮定する
		elite_num = 0;
		//従って、エリートの点数としてとりあえず一番最初の個体の成績を代入する
		best_seiseki = seiseki[0];
		//次の番号の個体から順に見てエリートよりも点数が良ければ、その個体をエリートとする作業を全ての個体を見終わるまで繰り返せば、一番成績のよいのがみつかる
		for (i = 1 ; i < KOTAISUU ; i ++) {
			if (best_seiseki < seiseki[i]) {
				//もし仮のエリートよりも成績のよいのが見つかったら、エリート個体の番号と成績を更新する
				elite_num = i;
				best_seiseki = seiseki[i];
			}
		}
		//elite_numにはこの世代で最も成績のよい個体の番号が入っているので、その遺伝子を、エリート配列に入れる
		for (i = 0 ; i < GENE_LEN ; i ++) {
			elite[i] = gene[elite_num][i];
		}
		//ルーレット選択に入る。まずその世代の全ての個体の成績の総和を求める
		total = 0.0;
		//成績の総和を表すtotal変数に、全ての個体の成績を足しこむ
		for (i = 0 ; i < KOTAISUU ; i ++) {
			total += seiseki[i];
		}
		//次世代も決められた個体数を用意するのだから、その数だけルーレットの矢を当てる処理を繰り返す
		for (i = 0 ; i < KOTAISUU ; i ++) {
			//０〜１の間で、小数点以下４位迄の精度でランダムに少数をとり、これを矢の当たる位置とする。それに成績の総和を掛ける
			rulet_cf = (double) (rando (10000)) / 10000.0 * total;
			//矢が何番目の個体に当たったかを割り出す。これは番号の若い個体から順に成績を足し込み、その足しこんだ値がrulet_cfを超えたときの個体である
			rulet_value = 0.0;
			for (j = 0 ; j < KOTAISUU ; j ++) {
				rulet_value += seiseki[j];
				//もし足しこんだ値が矢の位置を越えたら、その個体番号を記録し、次の矢を射る操作に戻る
				if (rulet_value > rulet_cf) {
					rulet_num = j;
					break;
				}
			}
			//仮の個体群配列に選択された個体を入れる
			for (j = 0 ; j < GENE_LEN ; j ++) {
				temp_gene[i][j] = gene[rulet_num][j];
			}
		}
		//個体数分、ルーレット選択が終わったところで、仮の個体群配列を真の個体群配列にコピーして、次世代の個体群を得る
		for (i = 0 ; i < KOTAISUU ; i ++) {
			for (j = 0 ; j < GENE_LEN ; j ++) {
				gene[i][j] = temp_gene[i][j];
			}
		}
		//交叉に入る。番号の若い個体から順に２つずつペアとし、各ペアについて交叉率に従って交叉をする（ここでは、交叉率９５％なので、２０組に１組の確率で交叉をしないペアが現れる）
		//各ペアごとに処理するので、個体群の配列を２つずつ見ていく
		for (i = 0 ; i < KOTAISUU ; i += 2) {
			//まずそのペアが交叉を行うかどうかを決めるため、小数点以下２桁までの０〜１の間の少数をランダムにとる
			d_ret = (double) rando (101) / 100.0;
			//その値が交叉率より低ければ交叉を行う
			if (d_ret < CROS_RATE) {
				//一点交叉（切断点が一つだけの交叉）における切断点をランダムに決定する（遺伝子の長さ分、切断点の候補はある）
				pos = rando (GENE_LEN);
				//一点交叉は切断点より後ろの遺伝子を入れ替えればよいので、for文はposの位置から始まる
				for (j = pos ; j < GENE_LEN ; j ++) {
					//ペアのうち番号の若い遺伝子のjの位置の遺伝子座の持つ値を入替用変数に待避させる
					temp = gene[i][j];
					//番号の若い遺伝子のjの位置の遺伝子座に、相手の遺伝子の同じ位置の遺伝子座の値を代入する
					gene[i][j] = gene[i + 1][j];
					//相手の遺伝子のjの位置の遺伝子座に、待避させておいた番号の若い方の遺伝子のjの位置の遺伝子座の値を代入することでjの位置の入れ替終了
					gene[i + 1][j] = temp;
				}
			}
		}
		//突然変異に入る。突然変異は全個体の全ての遺伝子座に対して、突然変異率に従って行う（この場合、突然変異率は５％に設定しているので、２０個の遺伝子座のうち１個の割合で変化を受ける）
		for (i = 0 ; i < KOTAISUU ; i ++) {
			//各個体について全ての遺伝子座を見る
			for (j = 0 ; j < GENE_LEN ; j ++) {
				//この遺伝子座が突然変異を受けるかどうかを決めるため、小数点以下２桁までの０〜１の間の少数をランダムにとる
				d_ret = (double) rando (101) / 100.0;
				//その値が突然変異率より低ければ突然変異を行う
				if (d_ret < MUTA_RATE) {
					//突然変異は、初期個体群生成のときに代入したランダムな値を、そこの遺伝子座に代入する
					gene[i][j] = rando (ITEM_MAX);
				}
			}
		}
		//以上で、進化の為の操作を終わる。待避しておいた前世代のエリートを新しい世代の最初の番号の個体として戻す
		for (i = 0 ; i < GENE_LEN ; i ++) {
			gene[0][i] = elite[i];
		}
		//以上で、一世代に対して行う操作は全て終了なので、世代交代数を表す変数をインクリメント（１つ増やすこと）する
		counter ++;
		//もし、世代交代数が記録すべき世代数であればエリートの点数を書き出す
		if (counter % SEDAI_REC == 0) {
			printf ("counter = %d best = %lf\n" , counter , best_seiseki);
		}
		//もし、世代交代数が終了すべき世代数であれば、whileを抜け出し進化の過程を終了する
		if (counter == SEDAI_MAX) {
			break;
		}
	}
	//進化の過程が終了したら、最終世代のエリートの遺伝子の値をファイルに書き出す（ここでは、kiroku.datという名前のファイルに書くものとする）
	//ファイルを開く
	fp = fopen ("kiroku.dat" , "w");
	for (i = 0 ; i < GENE_LEN ; i ++) {
		fprintf (fp , "%d " , gene[0][i]);
	}
	//最後に改行しておく
	fprintf (fp , "\n");
	//ファイルを閉じる
	fclose (fp);
}

//乱数発生関数。整数Ｎを受け取り０から(Ｎ−１)までの整数をランダムに返す
int rando (int num) {
	int ret;
	//rand関数は０〜３２７６７のうちランダムに一つの整数を返す。これをＮで割った余りは、０〜Ｎ−１の整数のどれかとなる
	ret = rand ();
	ret = ret % num;
	//割った余りを返す
	return ret;
}
